var documenterSearchIndex = {"docs":
[{"location":"#Configurations","page":"Home","title":"Configurations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Configurations & Options made easy.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Create an option type with macro @option as following","category":"page"},{"location":"","page":"Home","title":"Home","text":"@option struct YouOptionType <: YourAbstractType\n   a::Int = 1\n   b::Float64 # required field\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"then you can use this as an option type, it can let you:","category":"page"},{"location":"","page":"Home","title":"Home","text":"convert an option type defined in Julia to a markup language, such as TOML, JSON\nread from plain AbstractDict{String}, TOML, JSON etc. and convert the data to the option type\ncompose several option types together","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can easily create hierarchical struct types as following","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> \"Option A\"\n       @option \"option_a\" struct OptionA\n           name::String\n           int::Int = 1\n       end\n\njulia> \"Option B\"\n       @option \"option_b\" struct OptionB\n           opt::OptionA = OptionA(;name = \"Sam\")\n           float::Float64 = 0.3\n       end","category":"page"},{"location":"","page":"Home","title":"Home","text":"and convert a dict to an option type via from_dict.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> d = Dict{String, Any}(\n           \"opt\" => Dict{String, Any}(\n               \"name\" => \"Roger\",\n               \"int\" => 2,\n           ),\n           \"float\" => 0.33\n       );\n\njulia> option = from_dict(OptionB, d)\nOptionB(;\n    opt = OptionA(;\n        name = \"Roger\",\n        int = 2,\n    ),\n    float = 0.33,\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"when there are multiple possible option type for one field, one can use the alias to distinguish them","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> @option struct OptionD\n           opt::Union{OptionA, OptionB}\n       end\n\njulia> d1 = Dict{String, Any}(\n               \"opt\" => Dict{String, Any}(\n                   \"option_b\" => d\n               )\n           );\n\njulia> from_dict(OptionD, d1)\nOptionD(;\n    opt = OptionB(;\n        opt = OptionA(;\n            name = \"Roger\",\n            int = 2,\n        ),\n        float = 0.33,\n    ),\n)\n\njulia> using Configurations\n\njulia> @option struct OptionA\n           name::String\n           int::Int = 1\n       end\n\njulia> @option struct OptionB\n           opt::OptionA = OptionA(;name = \"Sam\")\n           float::Float64 = 0.3\n       end\n\njulia> d = Dict(\n           \"opt\" => Dict(\n               \"name\" => \"Roger\",\n               \"int\" => 2,\n           ),\n           \"float\" => 0.33\n       )\nDict{String, Any} with 2 entries:\n  \"opt\"   => Dict{String, Any}(\"int\"=>2, \"name\"=>\"Roger\")\n  \"float\" => 0.33\n\njulia> option = from_dict(OptionB, d)\nOptionB(;\n  opt = OptionA(;\n    name = \"Roger\",\n    int = 2,\n  ),\n  float = 0.33,\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or you can also create it from keyword arguments, e.g","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> from_kwargs(OptionB; opt_name=\"Roger\", opt_int=2, float=0.33)\nOptionB(;\n    opt = OptionA(;\n        name = \"Roger\",\n        int = 2,\n    ),\n    float = 0.33,\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"for option types you can always convert AbstractDict to a given option type, or convert them back to dictionary via to_dict, e.g","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Configurations.to_dict(option)\nOrderedDict{String, Any} with 2 entries:\n  \"opt\"   => OrderedDict{String, Any}(\"name\"=>\"Roger\", \"int\"=>2)\n  \"float\" => 0.33","category":"page"},{"location":"","page":"Home","title":"Home","text":"for serialization, you can use the builtin TOML support","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> to_toml(option)\n\"float = 0.33\\n\\n[opt]\\nname = \\\"Roger\\\"\\nint = 2\\n\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or serialize it to other format from OrderedDict.","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Configurations]","category":"page"},{"location":"#Configurations.Maybe","page":"Home","title":"Configurations.Maybe","text":"maybe of type T or nothing\n\n\n\n\n\n","category":"type"},{"location":"#Configurations.no_default","page":"Home","title":"Configurations.no_default","text":"const for non default fields\n\n\n\n\n\n","category":"constant"},{"location":"#Configurations.Field","page":"Home","title":"Configurations.Field","text":"Field\n\nType to represent a field definition in option type.\n\n\n\n\n\n","category":"type"},{"location":"#Configurations.OptionDef","page":"Home","title":"Configurations.OptionDef","text":"OptionDef\n\nType to represent the option type definition.\n\n\n\n\n\n","category":"type"},{"location":"#Configurations.codegen-Tuple{Configurations.OptionDef}","page":"Home","title":"Configurations.codegen","text":"generate Julia AST from OptionDef.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.compare_options-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Home","title":"Configurations.compare_options","text":"compare_options(a, b, xs...)::Bool\n\nCompare option types check if they are the same.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.create-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"Configurations.create","text":"create(::Type{T}; kwargs...) where T\n\nCreate an instance of option type T from kwargs. Similar to the default keyword argument constructor, but one can use this to create custom keyword argument constructor with extra custom keywords.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.dictionalize-Tuple{Any}","page":"Home","title":"Configurations.dictionalize","text":"dictionalize(x; include_defaults=false)\n\nConvert x to an OrderedDict.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.field_alias-Union{Tuple{T}, Tuple{Type{T},Symbol}} where T","page":"Home","title":"Configurations.field_alias","text":"field_alias(::Type{T}, name::Symbol) where {T}\n\nReturn field name alias of given option types.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.field_aliases-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"Configurations.field_aliases","text":"field_alias(::Type{T}) where T\n\nReturn all field name alias of given option types.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.field_default-Union{Tuple{T}, Tuple{Type{T},Symbol}} where T","page":"Home","title":"Configurations.field_default","text":"field_default(::Type{T}, name::Symbol)\n\nReturn the default value of field name of an option type T.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.field_defaults-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"Configurations.field_defaults","text":"field_defaults(::Type)\n\nReturn default values of given option types.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.from_dict-Union{Tuple{T}, Tuple{Type{T},AbstractDict{String,V} where V}} where T","page":"Home","title":"Configurations.from_dict","text":"from_dict(::Type{T}, d::AbstractDict{String}; kw...) where T\n\nConvert dictionary d to an option type T, the valud of valid fields of T in this dictionary d can be override by keyword arguments.\n\nExample\n\njulia> @option struct OptionA\n           name::String = \"Sam\"\n           age::Int = 25\n       end\n\njulia> d = Dict{String, Any}(\n           \"name\" => \"Roger\",\n           \"age\" => 10,\n       );\n\njulia> from_dict(OptionA, d; age=25)\nOptionA(;\n    name = \"Roger\",\n    age = 25,\n)\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.from_dict_inner-Union{Tuple{T}, Tuple{Type{T},AbstractDict{String,V} where V}} where T","page":"Home","title":"Configurations.from_dict_inner","text":"from_dict_inner(::Type{T}, d::AbstractDict{String}) where T\n\nInternal method to convert a dictionary (subtype of AbstractDict) to type T, this method will not check if T is an option type via is_option, and will not validate if all the required fields are available in the dict object.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.from_kwargs!-Union{Tuple{T}, Tuple{AbstractDict{String,V} where V,Type{T}}, Tuple{AbstractDict{String,V} where V,Type{T},Union{Nothing, Symbol}}} where T","page":"Home","title":"Configurations.from_kwargs!","text":"from_kwargs!(d::AbstractDict{String}, ::Type{T}, prefix::Maybe{Symbol} = nothing; kw...) where T\n\nInternal method for inserting keyword arguments to given dictionary object d. It will overwrite existing keys in d if it is specified by keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.from_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"Configurations.from_kwargs","text":"from_kwargs(::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T. See also from_dict.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.from_toml-Union{Tuple{T}, Tuple{Type{T},String}} where T","page":"Home","title":"Configurations.from_toml","text":"from_toml(::Type{T}, filename::String; kw...) where T\n\nConvert a given TOML file filename to an option type T. Valid fields can be override by keyword arguments. See also from_dict.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.is_option-Tuple{Any}","page":"Home","title":"Configurations.is_option","text":"is_option(x)\n\nCheck if x is an option type or not.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.keywords-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"Configurations.keywords","text":"keywords(::Type{T}) where T -> Vector{Symbol}\n\nGet all the keywords of type T.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.option_convert-Union{Tuple{A}, Tuple{Type,Type{A},Any}} where A","page":"Home","title":"Configurations.option_convert","text":"option_convert(::Type{OptionType}, ::Type{ValueType}, x) where {OptionType, ValueType}\n\nConvert x to type ValueType for option type OptionType. This is similar to Base.convert, when creating an instance of the option type, but one can use this to avoid type piracy.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.pick_union-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Home","title":"Configurations.pick_union","text":"pick_union(::Type, x) -> type, value\n\nPick a type T and its corresponding value from a Union. For option types it should be a dictionary type. The value can be furthur converted to this type T via option_convert or Base.convert.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.split_body-Tuple{Expr}","page":"Home","title":"Configurations.split_body","text":"split_body(ex::Expr) -> fields::Vector{Field}, misc::Vector{Any}\n\nSplit the fields of option type declaration and misc (such as inner constructors etc.).\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.split_name-Tuple{Expr}","page":"Home","title":"Configurations.split_name","text":"split_name(ex::Expr) -> name, typevars, supertype\n\nSplit the name, type parameters and supertype definition from struct declaration head.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.to_dict-Tuple{Any}","page":"Home","title":"Configurations.to_dict","text":"to_dict(option; include_defaults=false) -> OrderedDict\n\nConvert an option to an OrderedDict. \n\nto_dict does not export fields that are of the same values as the defaults.  This can be overridden by changing include_defaults to true.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.to_toml-Tuple{Any,IO,Any}","page":"Home","title":"Configurations.to_toml","text":"to_toml([f::Function], io::IO, option; sorted=false, by=identity, include_defaults=false)\n\nConvert an instance option of option type to TOML and write it to IO. See also TOML.print.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.to_toml-Tuple{Any,String,Any}","page":"Home","title":"Configurations.to_toml","text":"to_toml([f::Function], filename::String, option; sorted=false, by=identity, include_defaults=false)\n\nConvert an instance option of option type to TOML and write it to filename. See also TOML.print.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.to_toml-Tuple{Any}","page":"Home","title":"Configurations.to_toml","text":"to_toml(x; sorted=false, by=identity, include_defaults=false)\n\nConvert an instance x of option type to TOML and write it to String. See also TOML.print. \n\nto_toml does not export fields that are of the same values as the defaults. This can be  overridden by changing include_defaults to true.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.toml_convert-Tuple{Type,Any}","page":"Home","title":"Configurations.toml_convert","text":"toml_convert(::Type, x)\n\nA convenient function for converting common Julia types to TOML compatible types. One can overload the first argument to custom the behaviour for a specific option type.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.toml_convert-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"Configurations.toml_convert","text":"toml_convert(::Type{T}) where T\n\nCurried version of toml_convert.\n\n\n\n\n\n","category":"method"},{"location":"#Configurations.@option-Tuple{Any}","page":"Home","title":"Configurations.@option","text":"@option [alias::String] <struct def>\n\nDefine an option struct type. This will auto-generate methods that parse a given Dict{String} object (the keys must be of type String) into an instance of the struct type you defined. One can use alias string to distinguish multiple possible option type for the same field.\n\nExample\n\nOne can define option type via @option macro with or without an alias.\n\njulia> \"Option A\"\n       @option \"option_a\" struct OptionA\n           name::String\n           int::Int = 1\n       end\n\njulia> \"Option B\"\n       @option \"option_b\" struct OptionB\n           opt::OptionA = OptionA(;name = \"Sam\")\n           float::Float64 = 0.3\n       end\n\nand convert a dict to an option type via from_dict.\n\njulia> d = Dict{String, Any}(\n           \"opt\" => Dict{String, Any}(\n               \"name\" => \"Roger\",\n               \"int\" => 2,\n           ),\n           \"float\" => 0.33\n       );\n\njulia> option = from_dict(OptionB, d)\nOptionB(;\n    opt = OptionA(;\n        name = \"Roger\",\n        int = 2,\n    ),\n    float = 0.33,\n)\n\nwhen there are multiple possible option type for one field, one can use the alias to distinguish them\n\njulia> @option struct OptionD\n           opt::Union{OptionA, OptionB}\n       end\n\njulia> d1 = Dict{String, Any}(\n               \"opt\" => Dict{String, Any}(\n                   \"option_b\" => d\n               )\n           );\n\njulia> from_dict(OptionD, d1)\nOptionD(;\n    opt = OptionB(;\n        opt = OptionA(;\n            name = \"Roger\",\n            int = 2,\n        ),\n        float = 0.33,\n    ),\n)\n\n\n\n\n\n","category":"macro"}]
}
